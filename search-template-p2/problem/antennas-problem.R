# =========================================================================
# This script has been created from a version generated by ChatGPT v3.5 and
# GitHub Copilot
# =========================================================================

# This function must return the problem structure
initialize.problem <- function(filename) {
  
  # Read the input file
  lines <- readLines(filename)
  first_line <- strsplit(lines[1], " ")[[1]]
  
  # The first line contains the number of antennas and the radio of coverage
  num_antennas <- as.numeric(first_line[1])
  radio <- as.numeric(first_line[2])
  
  # The rest of lines contain the coordinates to be covered
  coord_lines <- lines[-1]
  positions <- do.call(rbind, lapply(coord_lines, function(line) {
    vals <- strsplit(line, " ")[[1]]
    c(as.numeric(vals[1]), as.numeric(vals[2]))
  }))
  
  # Create the problem structure
  problem <- list()
  problem$name         <- paste0("Antenna Coverage - [", filename, "]")
  problem$num_antennas <- num_antennas
  problem$radio        <- radio
  problem$positions    <- positions
  # Generate the first state with taking the first positions as reference
  # initial_state <- rep(positions[1, ], num_antennas)
  
  # Modificaci칩n a침adida para cumplir el enunciado del proyecto:
  # el estado inicial debe ser una selecci칩n aleatoria de posiciones de antenas,
  # tal como se indica en la definici칩n del problema (estado inicial aleatorio).
  sel <- sample(nrow(positions), num_antennas, replace = TRUE)
  initial_state <- as.vector(t(positions[sel, ]))
  
  problem$state_initial <- initial_state
  # Initialize actions with a sequence from 1 to the number of antennas available
  action_list <- c()
  for (antena in seq_len(num_antennas)) {
    action_list <- c(action_list,
                     paste0("CambiarLocalizacion-", antena),
                     paste0("CambiarLocalizacion-", antena),
                     paste0("CambiarLocalizacion-", antena))
  }
  
  problem$actions.possible <- data.frame(action = action_list, stringsAsFactors = FALSE)
  
  return(problem)
}

# Analyzes if an action can be applied in the received state.
is.applicable <- function (state, action, problem) {
  # In this problem, any action is always applicable
  return(TRUE)
}

# Returns the state resulting on applying the action over the state
effect <- function (state, action, problem) {
  # Make a copy of the state
  result <- state
  
  #Extract which antenna was moved
  parts <- strsplit(action, "-")[[1]]
  antena_index <- as.numeric(parts[2])
  
  punto_index <- sample(nrow(problem$positions), 1)
  
  new_x <- problem$positions[punto_index, 1]
  new_y <- problem$positions[punto_index, 2]
  
  x_pos_in_state <- (antena_index - 1) * 2 + 1
  y_pos_in_state <- (antena_index - 1) * 2 + 2
  
  # Update the coverage
  result[x_pos_in_state] <- new_x
  result[y_pos_in_state] <- new_y
  
  return(result)
}

# Analyzes if a state is final or not
is.final.state <- function (state, final_state, problem) {
  # Always return TRUE as every state is considered final
  return(TRUE)
}

# Transforms a state into a string
to.string = function (state, problem) {
  num_antennas <- problem$num_antennas
  txt <- ""
  for (i in seq_len(num_antennas)) {
    x_pos <- state[(2 * (i - 1) + 1)]
    y_pos <- state[(2 * (i - 1) + 2)]
    txt <- paste0(txt, "Antena ", i, ": (", x_pos, ", ", y_pos, ")  ")
  }
  return(txt)
}

# Returns the cost of applying an action over a state
get.cost <- function (action, state, problem) {
  # Cost is always 1 in this problem
  return(1)
}

# Heuristic function used by Informed Search Algorithms
get.evaluation <- function(state, problem) {
  num_antennas <- problem$num_antennas
  radio <- problem$radio
  puntos <- problem$positions
  
  # Generate a list of booleans to determine which points are covered
  cubierto <- rep(FALSE, nrow(puntos))
  
  # If one antenna is covering points, turn them to true
  for (i in seq_len(num_antennas)) {
    x_ant <- state[(2 * (i - 1) + 1)]
    y_ant <- state[(2 * (i - 1) + 2)]
    
    distancias <- sqrt((puntos[,1] - x_ant)^2 + (puntos[,2] - y_ant)^2)
    cubierto[distancias <= radio] <- TRUE
  }
  
  # Return number of points covered (TRUE)
  return(sum(!cubierto))
}

plot.state <- function(state, problem) {
  x_coords <- problem$positions[, 1]
  y_coords <- problem$positions[, 2]
  
  plot(x_coords, y_coords,
       xlab = "X", ylab = "Y",pch = 19, col = "black",cex = 1.2)
  
  for (i in seq_len(problem$num_antennas)) {
    x_ant <- state[2*(i-1) + 1]
    y_ant <- state[2*(i-1) + 2]
    points(x_ant, y_ant,pch = 21,col = "black", bg  = "red",cex = 3)
    symbols(x_ant, y_ant,circles = problem$radio,inches = FALSE,add = TRUE,fg = "red",lwd= 3)
  }
}